/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 static/models/book.glb -k -t 
*/

import * as THREE from 'three';
import React, { useRef, useState } from 'react';
import { useGLTF, useAnimations, useScroll } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { prefix } from '../utility/environment';
import { useFrame } from '@react-three/fiber';

type GLTFResult = GLTF & {
  nodes: {
    book_cover002: THREE.Mesh;
    book_cover002_1: THREE.Mesh;
    book_cover002_2: THREE.Mesh;
    book_cover003: THREE.Mesh;
    book_cover003_1: THREE.Mesh;
  };
  materials: {
    Base_sheets: THREE.MeshStandardMaterial;
    book_cover: THREE.MeshStandardMaterial;
    Presentation: THREE.MeshPhysicalMaterial;
  };
  animations: GLTFAction[];
};

type ActionName = 'book_upAction.001' | 'book_dwnAction.001';
interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}
type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['mesh']>>;

const Book = (props: JSX.IntrinsicElements['group']) => {
  const group = useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF(prefix + '/models/book.glb') as GLTFResult;
  const { actions } = useAnimations(animations, group);

  const [animated, setAnimated] = useState<boolean>(false);

  const data = useScroll();

  useFrame(() => {
    console.log(data.offset);
    if (!animated && data.offset > 0.26) {
      setAnimated(true);
      for (const a of animations) {
        const animObj = actions[a.name];
        if (animObj) {
          animObj.reset();
          animObj.timeScale = 1;
          animObj.setLoop(THREE.LoopOnce, 1);
          animObj.clampWhenFinished = true;
          animObj.play();
        }
      }
    }
    if (animated && (data.offset > 0.4 || data.offset < 0.26)) {
      setAnimated(false);
      for (const a of animations) {
        const animObj = actions[a.name];
        if (animObj) {
          animObj.paused = false;
          animObj.timeScale = -1;
          animObj.setLoop(THREE.LoopOnce, 1);
          animObj.play();
        }
      }
    }
    // else if (data.offset > 1) for (const a of closing) closeBook[a.name]?.reset().play();
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="book_up" position={[0.301, 0, 0.008]} rotation={[-Math.PI, -Math.PI / 2, 0]} scale={0.942}>
          <mesh name="book_cover002" geometry={nodes.book_cover002.geometry} material={materials.Base_sheets} />
          <mesh name="book_cover002_1" geometry={nodes.book_cover002_1.geometry} material={materials.book_cover} />
          <mesh name="book_cover002_2" geometry={nodes.book_cover002_2.geometry} material={materials.Presentation} />
        </group>
        <group name="book_dwn" position={[0.301, -0.138, 0.353]} rotation={[-Math.PI, -Math.PI / 2, 0]} scale={0.942}>
          <mesh name="book_cover003" geometry={nodes.book_cover003.geometry} material={materials.Base_sheets} />
          <mesh name="book_cover003_1" geometry={nodes.book_cover003_1.geometry} material={materials.book_cover} />
        </group>
      </group>
    </group>
  );
};

useGLTF.preload(prefix + '/models/book.glb');
export default Book;

